[
  {
    "rule": "변수 이름은 역할을 명확히 설명해야 하며, 축약하지 않는다."
  },
  {
    "rule": "불리언 변수는 is, has, can 등의 접두어를 사용한다."
  },
  {
    "rule": "컬렉션 변수에는 복수형 이름을 사용한다. 예: users, orders"
  },
  {
    "rule": "변수 이름에 타입 정보를 포함하지 않는다 (userList는 OK, lstUser는 NO)"
  },
  {
    "rule": "루프 변수는 의미가 명확할 경우만 i, j 등 짧은 이름을 허용한다."
  },
  {
    "rule": "클래스 이름은 UpperCamelCase로 작성한다."
  },
  {
    "rule": "메서드는 동사로 시작하고, camelCase를 따른다."
  },
  {
    "rule": "상수는 SCREAMING_SNAKE_CASE로 작성한다."
  },
  {
    "rule": "패키지 이름은 모두 소문자이며 밑줄, 대문자 없이 com.project.module 형식이다."
  },
  {
    "rule": "enum 값은 대문자 스네이크로 작성한다. 예: PENDING_APPROVAL"
  },
  {
    "rule": "DTO, VO, Entity 등은 접미사로 명확히 구분한다. 예: UserDto, UserEntity"
  },
  {
    "rule": "도메인 용어를 사용하여 이름 짓기를 통일한다."
  },
  {
    "rule": "인터페이스는 -able, -ible, -er 접미사를 사용한다."
  },
  {
    "rule": "test 클래스는 XxxTest 형식으로 명명한다."
  },
  {
    "rule": "이벤트 클래스는 XxxEvent로 통일한다."
  },
  {
    "rule": "들여쓰기는 스페이스 4칸으로 통일한다."
  },
  {
    "rule": "클래스와 메서드 사이에는 공백 한 줄을 유지한다."
  },
  {
    "rule": "중괄호는 한 줄로 열고 한 줄로 닫는다 (K&R 스타일)."
  },
  {
    "rule": "else는 }와 같은 줄에 작성한다."
  },
  {
    "rule": "줄 길이는 120자를 넘기지 않는다."
  },
  {
    "rule": "연산자는 줄 끝이 아닌 다음 줄로 넘긴다."
  },
  {
    "rule": "@Override는 반드시 명시한다."
  },
  {
    "rule": "주석과 코드 사이에는 공백 한 줄을 둔다."
  },
  {
    "rule": "파일 끝에는 항상 한 줄 공백을 추가한다."
  },
  {
    "rule": "import 구문은 java., javax., org., com. 순서로 정렬한다."
  },
  {
    "rule": "if, for, while, do 등에는 항상 중괄호 {}를 사용한다."
  },
  {
    "rule": "return, break, continue는 복잡한 조건문 안에서 사용을 자제한다."
  },
  {
    "rule": "switch 문에는 반드시 default를 포함한다."
  },
  {
    "rule": "switch 문에서 break 누락 시 // fallthrough 주석을 명시한다."
  },
  {
    "rule": "중첩 if/else는 가능한 줄이고, Guard Clause로 리팩토링한다."
  },
  {
    "rule": "한 줄짜리 if 문도 중괄호를 생략하지 않는다."
  },
  {
    "rule": "else if는 필요한 경우에만 사용하고, 상태를 분리할 수 있다면 분기 클래스로 리팩토링한다."
  },
  {
    "rule": "메서드는 가능하면 early return을 사용한다."
  },
  {
    "rule": "null 체크는 먼저 수행하고, 가능한 빨리 종료한다."
  },
  {
    "rule": "복잡한 조건문은 의미 있는 변수로 분리한다."
  },
  {
    "rule": "클래스 내 멤버는 상수 > 필드 > 생성자 > public > protected > private 순으로 정리한다."
  },
  {
    "rule": "한 클래스에는 한 책임만 가진다 (SRP)."
  },
  {
    "rule": "클래스는 가능한 작게 유지한다. 200줄을 넘지 않도록 노력한다."
  },
  {
    "rule": "내부 클래스를 남용하지 않는다."
  },
  {
    "rule": "유틸리티 클래스는 final이며 생성자는 private이다."
  },
  {
    "rule": "인터페이스는 동작을 표현하며, Manager, Processor 등 포괄적 이름은 지양한다."
  },
  {
    "rule": "상속보다는 조합을 우선 고려한다."
  },
  {
    "rule": "모든 public 클래스에는 JavaDoc을 작성한다."
  },
  {
    "rule": "의존성 주입을 위해 생성자 주입을 기본으로 사용한다."
  },
  {
    "rule": "Lombok을 사용할 경우 @RequiredArgsConstructor 또는 명시적인 생성자를 사용한다."
  },
  {
    "rule": "Exception은 최상위 부모인 Exception보다는 의미 있는 하위 타입을 사용한다."
  },
  {
    "rule": "RuntimeException을 남용하지 않는다."
  },
  {
    "rule": "예외 메시지는 문제 원인을 설명해야 하며, 클라이언트가 이해할 수 있어야 한다."
  },
  {
    "rule": "예외는 처리하거나 명확히 던진다. 삼키지 않는다."
  },
  {
    "rule": "catch 블록 안에서는 반드시 로그를 남긴다."
  },
  {
    "rule": "여러 catch 블록을 사용할 경우 구체적인 예외부터 순서대로 나열한다."
  },
  {
    "rule": "커스텀 예외는 XxxException 명명하고, 의미를 명확히 한다."
  },
  {
    "rule": "checked 예외는 실제 복구 가능한 상황에서만 사용한다."
  },
  {
    "rule": "예외 wrapping 시 원래의 stack trace를 유지한다."
  },
  {
    "rule": "예외를 위한 컨벤션 코드, 예: ErrorCode, ExceptionType 등 사용을 권장한다."
  },
  {
    "rule": "함수는 한 가지 일만 해야 한다."
  },
  {
    "rule": "함수의 길이는 20줄 이내를 권장한다."
  },
  {
    "rule": "함수명은 무엇을 하는지 명확히 표현한다."
  },
  {
    "rule": "매개변수는 3개 이하로 제한한다."
  },
  {
    "rule": "boolean 파라미터는 가능한 피하고, Enum 또는 전략 객체로 대체한다."
  },
  {
    "rule": "Side effect가 없는 함수를 지향한다."
  },
  {
    "rule": "전역 상태에 의존하지 않도록 한다."
  },
  {
    "rule": "중복을 제거하되, 의미상 유사하지 않다면 합치지 않는다."
  },
  {
    "rule": "주석보다 코드를 개선하는 방향을 우선시한다."
  },
  {
    "rule": "불필요한 catch/throw, 불필요한 설정/주입 코드를 제거한다."
  },
  {
    "rule": "함수 추출은 리팩토링의 기본이다."
  },
  {
    "rule": "조건문은 다형성 또는 전략 패턴으로 대체할 수 있다면 리팩토링한다."
  },
  {
    "rule": "switch 문은 상태 패턴으로 리팩토링을 고려한다."
  },
  {
    "rule": "Feature Envy가 심한 메서드는 소유 클래스에 이동한다."
  },
  {
    "rule": "Long Parameter List는 DTO나 VO로 묶는다."
  },
  {
    "rule": "Primitive Obsession은 객체로 전환한다."
  },
  {
    "rule": "Data Clumps(데이터 뭉치)는 클래스로 추출한다."
  },
  {
    "rule": "긴 메서드는 작은 private 메서드로 나눈다."
  },
  {
    "rule": "불변 객체를 활용하여 상태 변이를 최소화한다."
  },
  {
    "rule": "테스트 가능성을 위해 외부 의존성을 분리한다."
  },
  {
    "rule": "테스트 클래스명은 대상 클래스 + Test로 작성한다."
  },
  {
    "rule": "테스트 메서드는 should_동작명_when_조건 형식으로 작성한다."
  },
  {
    "rule": "테스트는 AAA (Arrange-Act-Assert) 구조로 작성한다."
  },
  {
    "rule": "테스트는 독립적으로 실행 가능해야 한다."
  },
  {
    "rule": "테스트 간 공유 상태는 금지한다."
  },
  {
    "rule": "목 객체는 외부 시스템이나 느린 컴포넌트에 대해서만 사용한다."
  },
  {
    "rule": "테스트에서 비즈니스 로직을 다시 구현하지 않는다."
  },
  {
    "rule": "단위 테스트는 상태 기반(State-based)을 우선하고, 상호작용 기반(Interaction-based)은 최소화한다."
  },
  {
    "rule": "단위 테스트는 실패 이유를 명확히 알려줘야 한다."
  },
  {
    "rule": "flaky test(간헐적 실패)는 배포 전에 반드시 수정한다."
  },
  {
    "rule": "하드코딩된 문자열은 설정 파일 또는 상수로 분리한다."
  },
  {
    "rule": "매직 넘버는 상수로 치환한다."
  },
  {
    "rule": "로그 레벨은 적절히 구분한다 (info, warn, error)."
  },
  {
    "rule": "외부 API 호출 시 타임아웃과 재시도 정책을 명시한다."
  },
  {
    "rule": "Entity를 직접 반환하지 말고 DTO로 변환한다."
  },
  {
    "rule": "Entity 내부에는 비즈니스 로직만 포함한다."
  },
  {
    "rule": "REST API 컨트롤러는 상태를 저장하지 않는다."
  },
  {
    "rule": "클라이언트에 반환되는 에러 메시지는 구체적이고 안전해야 한다."
  },
  {
    "rule": "scheduled task는 로그로 상태를 남겨야 한다."
  },
  {
    "rule": "캐시된 값은 유효성 검증이 있어야 하며 TTL 설정을 검토한다."
  },
  {
    "rule": "단일 책임 원칙은 서비스 계층에서도 유지해야 한다."
  },
  {
    "rule": "builder 사용 시 필수값이 명확히 드러나도록 설계한다."
  },
  {
    "rule": "포맷터(google-java-format 등) 자동 적용을 권장한다."
  },
  {
    "rule": "Git 커밋 메시지는 형식을 통일한다. 예: feat: 기능 추가, fix: 버그 수정"
  }
]